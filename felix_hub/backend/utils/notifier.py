import os
import sys
import requests
from typing import Optional
from time import sleep
import logging
import hashlib
from datetime import datetime, timedelta

# Import translations from bot
bot_path = os.path.join(os.path.dirname(__file__), '../../bot')
sys.path.insert(0, bot_path)
try:
    from translations import get_text
except ImportError:
    # Fallback if translations not available
    def get_text(key: str, lang: str = 'ru', **kwargs) -> str:
        return key

logger = logging.getLogger(__name__)

BOT_TOKEN = os.getenv('BOT_TOKEN')
TELEGRAM_API_URL = f"https://api.telegram.org/bot{BOT_TOKEN}"
FRONTEND_URL = os.getenv('FRONTEND_URL', 'https://felix-hub.example.com')


def send_telegram_notification(chat_id: str, message: str, parse_mode: str = 'HTML') -> bool:
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram —á–µ—Ä–µ–∑ Bot API.
    
    Args:
        chat_id: Telegram ID –ø–æ–ª—É—á–∞—Ç–µ–ª—è
        message: –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
        parse_mode: –†–µ–∂–∏–º –ø–∞—Ä—Å–∏–Ω–≥–∞ (HTML, Markdown)
        
    Returns:
        bool: True –µ—Å–ª–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ, False –ø—Ä–∏ –æ—à–∏–±–∫–µ
    """
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
        return False
    
    if not chat_id:
        logger.error("chat_id –Ω–µ —É–∫–∞–∑–∞–Ω")
        return False
    
    url = f"{TELEGRAM_API_URL}/sendMessage"
    payload = {
        "chat_id": chat_id,
        "text": message,
        "parse_mode": parse_mode
    }
    
    try:
        response = requests.post(url, json=payload, timeout=5)
        
        if response.status_code == 200:
            logger.info(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {chat_id}")
            return True
        else:
            logger.error(
                f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {response.status_code} - {response.text}"
            )
            return False
            
    except requests.exceptions.Timeout:
        logger.error(f"–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {chat_id}")
        return False
    except requests.exceptions.RequestException as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
        return False
    except Exception as e:
        logger.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
        return False


def notify_order_ready(order) -> bool:
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –º–µ—Ö–∞–Ω–∏–∫—É –æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∑–∞–∫–∞–∑–∞.
    
    Args:
        order: –û–±—ä–µ–∫—Ç Order –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        
    Returns:
        bool: True –µ—Å–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ
    """
    lang = getattr(order, 'language', 'ru') or 'ru'
    parts_list = "\n".join([f"  ‚Ä¢ {part}" for part in order.selected_parts])
    
    message = get_text('order_ready', lang,
        order_id=order.id,
        parts=parts_list,
        vin=order.vin,
        date=order.created_at.strftime('%d.%m.%Y %H:%M')
    )
    
    success = send_telegram_notification(order.telegram_id, message)
    
    if success:
        logger.info(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∑–∞–∫–∞–∑–∞ ‚Ññ{order.id} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")
    else:
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–∫–∞–∑–µ ‚Ññ{order.id}")
    
    return success


def notify_order_status_changed(order, old_status: str, new_status: str) -> bool:
    """
    –£–≤–µ–¥–æ–º–ª—è–µ—Ç –º–µ—Ö–∞–Ω–∏–∫–∞ –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–∫–∞–∑–∞.
    
    Args:
        order: –û–±—ä–µ–∫—Ç Order
        old_status: –ü—Ä–µ–¥—ã–¥—É—â–∏–π —Å—Ç–∞—Ç—É—Å
        new_status: –ù–æ–≤—ã–π —Å—Ç–∞—Ç—É—Å
        
    Returns:
        bool: True –µ—Å–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ
    """
    status_emoji = {
        '–Ω–æ–≤—ã–π': 'üÜï',
        '–≤ —Ä–∞–±–æ—Ç–µ': '‚è≥',
        '–≥–æ—Ç–æ–≤': '‚úÖ',
        '–≤—ã–¥–∞–Ω': 'üì¶'
    }
    
    emoji = status_emoji.get(new_status, '‚ùì')
    
    message = (
        f"{emoji} <b>–°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ ‚Ññ{order.id} –∏–∑–º–µ–Ω—ë–Ω</b>\n\n"
        f"–ë—ã–ª–æ: <i>{old_status}</i>\n"
        f"–°—Ç–∞–ª–æ: <b>{new_status}</b>\n\n"
        f"üöó VIN: {order.vin}"
    )
    
    if new_status in ['–≥–æ—Ç–æ–≤', '–≤—ã–¥–∞–Ω']:
        return send_telegram_notification(order.telegram_id, message)
    
    return True


def send_order_delayed_notification(order) -> bool:
    """
    –£–≤–µ–¥–æ–º–ª—è–µ—Ç –æ –∑–∞–¥–µ—Ä–∂–∫–µ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–∫–∞–∑–∞.
    
    Args:
        order: –û–±—ä–µ–∫—Ç Order
        
    Returns:
        bool: True –µ—Å–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ
    """
    message = (
        f"‚è∞ <b>–ó–∞–∫–∞–∑ ‚Ññ{order.id}</b>\n\n"
        f"–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫–∞–∑–∞ –∑–∞–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è.\n"
        f"–ú—ã —Å–≤—è–∂–µ–º—Å—è —Å —Ç–æ–±–æ–π, –∫–∞–∫ —Ç–æ–ª—å–∫–æ –∑–∞–ø—á–∞—Å—Ç–∏ –±—É–¥—É—Ç –≥–æ—Ç–æ–≤—ã.\n\n"
        f"üöó VIN: {order.vin}\n"
        f"–ü—Ä–∏–Ω–æ—Å–∏–º –∏–∑–≤–∏–Ω–µ–Ω–∏—è –∑–∞ –Ω–µ—É–¥–æ–±—Å—Ç–≤–∞! üôè"
    )
    
    return send_telegram_notification(order.telegram_id, message)


def send_bulk_notification(telegram_ids: list, message: str) -> dict:
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –º–∞—Å—Å–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.
    
    Args:
        telegram_ids: –°–ø–∏—Å–æ–∫ Telegram ID –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π
        message: –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
        
    Returns:
        dict: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ {'success': int, 'failed': int}
    """
    results = {'success': 0, 'failed': 0}
    
    for telegram_id in telegram_ids:
        if send_telegram_notification(telegram_id, message):
            results['success'] += 1
        else:
            results['failed'] += 1
    
    logger.info(
        f"–ú–∞—Å—Å–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: "
        f"—É—Å–ø–µ—à–Ω–æ={results['success']}, –æ—à–∏–±–æ–∫={results['failed']}"
    )
    
    return results


def send_with_retry(chat_id: str, message: str, max_retries: int = 3) -> bool:
    """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏"""
    for attempt in range(max_retries):
        if send_telegram_notification(chat_id, message):
            return True
        
        if attempt < max_retries - 1:
            sleep(2 ** attempt)
            logger.info(f"–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_retries}")
    
    return False


def _generate_message_hash(notification_type: str, order_id: int, mechanic_id: int) -> str:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ö–µ—à–∞ –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π"""
    content = f"{notification_type}:{order_id}:{mechanic_id}"
    return hashlib.sha256(content.encode()).hexdigest()


def _check_duplicate_notification(notification_type: str, order_id: int, mechanic_id: int, db_session) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–µ –±—ã–ª–æ –ª–∏ —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Ç–∞–∫–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 15 –º–∏–Ω—É—Ç
    
    Returns:
        True –µ—Å–ª–∏ –¥—É–±–ª–∏–∫–∞—Ç –Ω–∞–π–¥–µ–Ω, False –µ—Å–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –º–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å
    """
    try:
        from models import NotificationLog
        
        message_hash = _generate_message_hash(notification_type, order_id, mechanic_id)
        cutoff_time = datetime.utcnow() - timedelta(minutes=15)
        
        duplicate = NotificationLog.query.filter(
            NotificationLog.message_hash == message_hash,
            NotificationLog.sent_at > cutoff_time,
            NotificationLog.success == True
        ).first()
        
        return duplicate is not None
    except Exception as e:
        logger.warning(f"Error checking duplicate notification: {e}")
        return False


def _log_notification(notification_type: str, telegram_id: str, order_id: int = None, 
                      mechanic_id: int = None, success: bool = True, 
                      error_message: str = None, db_session=None):
    """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"""
    try:
        from models import NotificationLog
        
        message_hash = _generate_message_hash(notification_type, order_id or 0, mechanic_id or 0)
        
        log_entry = NotificationLog(
            notification_type=notification_type,
            order_id=order_id,
            mechanic_id=mechanic_id,
            telegram_id=telegram_id,
            message_hash=message_hash,
            success=success,
            error_message=error_message
        )
        
        if db_session:
            db_session.add(log_entry)
            db_session.commit()
            logger.info(f"Notification logged: {notification_type} for mechanic {mechanic_id}, order {order_id}")
    except Exception as e:
        logger.error(f"Error logging notification: {e}")


def _generate_deeplink(order_id: int, mechanic_token: str = None) -> str:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è deeplink –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –∑–∞–∫–∞–∑—É"""
    base_url = FRONTEND_URL.rstrip('/')
    path = f"/mechanic/orders/{order_id}"

    if mechanic_token:
        path = f"{path}?token={mechanic_token}"

    return f"{base_url}/#{path}"


def _generate_mechanic_token(mechanic_id: int, telegram_id: str) -> str:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –º–µ—Ö–∞–Ω–∏–∫–∞"""
    import jwt
    import time
    
    secret_key = os.getenv('SECRET_KEY', 'dev-secret-key')
    
    payload = {
        'mechanic_id': mechanic_id,
        'telegram_id': telegram_id,
        'exp': int(time.time()) + 86400  # 24 hours
    }
    
    token = jwt.encode(payload, secret_key, algorithm='HS256')
    return token


def notify_mechanic_assignment(order, mechanic, is_reassignment: bool = False, db_session=None) -> bool:
    """
    –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –º–µ—Ö–∞–Ω–∏–∫–∞ –æ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ –∏–ª–∏ –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ –∑–∞–∫–∞–∑–∞
    
    Args:
        order: –û–±—ä–µ–∫—Ç Order
        mechanic: –û–±—ä–µ–∫—Ç Mechanic
        is_reassignment: True –µ—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ
        db_session: SQLAlchemy session –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
        
    Returns:
        bool: True –µ—Å–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ
    """
    notification_type = 'mechanic_reassignment' if is_reassignment else 'mechanic_assignment'
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—É–±–ª–∏–∫–∞—Ç–∞
    if db_session and _check_duplicate_notification(notification_type, order.id, mechanic.id, db_session):
        logger.info(f"Duplicate notification prevented: {notification_type} for order {order.id}, mechanic {mechanic.id}")
        return True
    
    # –ü–æ–ª—É—á–∏—Ç—å telegram_id –º–µ—Ö–∞–Ω–∏–∫–∞
    telegram_id = mechanic.telegram_id
    
    if not telegram_id:
        logger.warning(f"Mechanic {mechanic.id} has no telegram_id, notification skipped")
        if db_session:
            _log_notification(notification_type, '', order.id, mechanic.id, 
                            success=False, error_message="No telegram_id", db_session=db_session)
        return False
    
    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –∞–≤—Ç–æ–ª–æ–≥–∏–Ω–∞
    try:
        mechanic_token = _generate_mechanic_token(mechanic.id, telegram_id)
    except Exception as e:
        logger.error(f"Error generating mechanic token: {e}")
        mechanic_token = None
    
    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è deeplink
    deeplink = _generate_deeplink(order.id, mechanic_token)
    
    # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    action_text = "–ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–µ–Ω" if is_reassignment else "–Ω–∞–∑–Ω–∞—á–µ–Ω"
    emoji = "üîÑ" if is_reassignment else "üîî"
    
    parts_list = "\n".join([f"  ‚Ä¢ {part}" for part in order.selected_parts[:5]])
    if len(order.selected_parts) > 5:
        parts_list += f"\n  ... –∏ –µ—â—ë {len(order.selected_parts) - 5}"
    
    message = (
        f"{emoji} <b>–ù–æ–≤—ã–π –∑–∞–∫–∞–∑ {action_text} –Ω–∞ –≤–∞—Å!</b>\n\n"
        f"üìã –ó–∞–∫–∞–∑ ‚Ññ{order.id}\n"
        f"üöó VIN: {order.vin}\n"
        f"üì¶ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {order.category}\n\n"
        f"<b>–ó–∞–ø—á–∞—Å—Ç–∏:</b>\n{parts_list}\n\n"
        f"üîó <a href='{deeplink}'>–û—Ç–∫—Ä—ã—Ç—å –∑–∞–∫–∞–∑ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏</a>"
    )
    
    # –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    success = send_telegram_notification(telegram_id, message)
    
    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    if db_session:
        _log_notification(
            notification_type, 
            telegram_id, 
            order.id, 
            mechanic.id, 
            success=success,
            error_message=None if success else "Failed to send",
            db_session=db_session
        )
    
    if success:
        logger.info(f"Assignment notification sent for order {order.id} to mechanic {mechanic.id}")
    else:
        logger.warning(f"Failed to send assignment notification for order {order.id} to mechanic {mechanic.id}")
    
    return success
